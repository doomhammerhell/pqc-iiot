<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PQC-IIoT Security Library</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Industrial IoT Post-Quantum Cryptography Implementation Guide">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="architecture.html"><strong aria-hidden="true">2.</strong> Security Architecture</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="security/threat_model.html"><strong aria-hidden="true">2.1.</strong> Threat Model</a></li><li class="chapter-item expanded "><a href="security/compliance.html"><strong aria-hidden="true">2.2.</strong> FIPS 140-3 Compliance</a></li></ol></li><li class="chapter-item expanded "><a href="usage.html"><strong aria-hidden="true">3.</strong> Usage Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="usage/mqtt.html"><strong aria-hidden="true">3.1.</strong> MQTT Integration</a></li><li class="chapter-item expanded "><a href="usage/coap.html"><strong aria-hidden="true">3.2.</strong> CoAP Integration</a></li></ol></li><li class="chapter-item expanded "><a href="hardware.html"><strong aria-hidden="true">4.</strong> Hardware Integration</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="hardware/tpm.html"><strong aria-hidden="true">4.1.</strong> TPM 2.0</a></li><li class="chapter-item expanded "><a href="hardware/secure_element.html"><strong aria-hidden="true">4.2.</strong> Secure Elements</a></li></ol></li><li class="chapter-item expanded "><a href="api.html"><strong aria-hidden="true">5.</strong> API Reference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">PQC-IIoT Security Library</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/doomhammerhell/pqc-iiot" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pqc-iiot-documentation-v10"><a class="header" href="#pqc-iiot-documentation-v10">PQC-IIoT Documentation v1.0</a></h1>
<p><strong>PQC-IIoT</strong> is a Rust-based security library designed to bring NIST-standard post-quantum cryptography (Kyber, Falcon) to resource-constrained Industrial IoT (IIoT) devices. It bridges the gap between modern cryptographic research and practical, mission-critical industrial applications.</p>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<ul>
<li><strong>Hybrid Encryption</strong>: Combines Kyber-768 (KEM) with AES-256-GCM for robust data confidentiality.</li>
<li><strong>Quantum-Resistant Signatures</strong>: Uses Falcon-512 for high-speed, low-latency identity verification and command signing.</li>
<li><strong>FIPS 140-3 Compliance Ready</strong>: Includes Power-On Self-Tests (POST), Integrity Checks, and an Approved Mode of Operation.</li>
<li><strong>Hardware Abstraction Layer (HAL)</strong>: Seamlessly integrates with TPM 2.0 and HSMs, keeping private keys secure in hardware.</li>
<li><strong>Secure Memory</strong>: Automatic zeroization of sensitive data using the <code>zeroize</code> crate.</li>
<li><strong>Protocols</strong>: Native support for Secure MQTT and CoAP.</li>
</ul>
<h2 id="why-pqc-for-iiot"><a class="header" href="#why-pqc-for-iiot">Why PQC for IIoT?</a></h2>
<p>Industrial systems often have lifespans exceeding 20 years. Devices deployed today effectively face the threat of quantum computers within their operational lifecycle ("Store Now, Decrypt Later"). PQC-IIoT ensures that critical infrastructure remains secure against future quantum attacks.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Add the library to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
pqc-iiot = "0.1.0"
</code></pre>
<p>See the <a href="usage.html">Usage Guide</a> for detailed integration steps.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This project is licensed under the MIT License.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="security-architecture"><a class="header" href="#security-architecture">Security Architecture</a></h1>
<p>PQC-IIoT employs a layered security architecture designed to withstand both classical and post-quantum threats while adhering to rigorous industrial standards.</p>
<h2 id="1-hardware-abstraction-layer-hal"><a class="header" href="#1-hardware-abstraction-layer-hal">1. Hardware Abstraction Layer (HAL)</a></h2>
<p>At the core is the <code>SecurityProvider</code> trait, which decouples cryptographic operations from the application logic. This allows:</p>
<ul>
<li><strong>Software Mode</strong>: Development and testing using <code>Zeroize</code>-protected memory.</li>
<li><strong>Hardware Mode</strong>: Production deployment using TPM 2.0 or HSMs (Hardware Security Modules) where private keys never leave the secure boundary.</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SecurityProvider: Send + Sync {
    fn kem_public_key(&amp;self) -&gt; &amp;[u8];
    fn sig_public_key(&amp;self) -&gt; &amp;[u8];
    fn decrypt(&amp;self, ciphertext: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    fn sign(&amp;self, message: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt;;
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h2 id="2-hybrid-encryption-confidentiality"><a class="header" href="#2-hybrid-encryption-confidentiality">2. Hybrid Encryption (Confidentiality)</a></h2>
<p>We utilize a hybrid Key Encapsulation Mechanism (KEM) approach:</p>
<ol>
<li><strong>Kyber-768/1024</strong> establishes a shared quantum-resistant secret.</li>
<li><strong>AES-256-GCM</strong> uses the shared secret to encrypt the actual data payload with high performance.</li>
</ol>
<p>This ensures that even if classical key exchange methods (ECDH) are broken by quantum computers, the session keys remain secure.</p>
<h2 id="3-post-quantum-identity-authentication"><a class="header" href="#3-post-quantum-identity-authentication">3. Post-Quantum Identity (Authentication)</a></h2>
<p>Identity is verified using <strong>Falcon-512</strong> signatures.</p>
<ul>
<li><strong>Strict Mode</strong>: Only peers with public keys manually added to the <code>KeyStore</code> (Allow-list) can communicate.</li>
<li><strong>TOFU (Trust On First Use)</strong>: Can be enabled for easier onboarding, but prints security warnings.</li>
</ul>
<h2 id="4-replay-protection"><a class="header" href="#4-replay-protection">4. Replay Protection</a></h2>
<p>To prevent replay attacks:</p>
<ol>
<li>Each encrypted packet includes a monotonically increasing <strong>Sequence Number</strong>.</li>
<li>The <code>KeyStore</code> persists the last seen sequence number for every peer.</li>
<li>Packets with <code>seq &lt;= last_seen</code> are dropped and logged as security events.</li>
</ol>
<h2 id="5-audit-logging"><a class="header" href="#5-audit-logging">5. Audit Logging</a></h2>
<p>A structured audit log records all security-critical events (key generation, authentication failures, replay attempts) for SIEM integration and compliance auditing.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threat-model"><a class="header" href="#threat-model">Threat Model</a></h1>
<p>This document outlines the threats PQC-IIoT is designed to mitigate.</p>
<h2 id="1-store-now-decrypt-later-sndl"><a class="header" href="#1-store-now-decrypt-later-sndl">1. "Store Now, Decrypt Later" (SNDL)</a></h2>
<p><strong>Threat</strong>: Attackers record encrypted traffic today, intending to decrypt it years later when a sufficiently powerful quantum computer becomes available.
<strong>Mitigation</strong>: Use of Kyber (KEM) ensures that session keys cannot be retroactively recovered by quantum algorithms like Shor's algorithm.</p>
<h2 id="2-identity-impersonation"><a class="header" href="#2-identity-impersonation">2. Identity Impersonation</a></h2>
<p><strong>Threat</strong>: An attacker attempts to masquerade as a legitimate sensor or controller to inject false data or commands.
<strong>Mitigation</strong>: Falcon digital signatures provide strong, quantum-resistant authentication. Strict Allow-listing of public keys prevents unauthorized devices from joining the network.</p>
<h2 id="3-replay-attacks"><a class="header" href="#3-replay-attacks">3. Replay Attacks</a></h2>
<p><strong>Threat</strong>: An attacker captures a valid command (e.g., "Open Valve") and re-transmits it later.
<strong>Mitigation</strong>: Encrypted packets contain a sequential counter. The receiver tracks the <code>last_seen</code> counter for each peer and rejects duplicates or out-of-order packets.</p>
<h2 id="4-key-extraction-from-memory"><a class="header" href="#4-key-extraction-from-memory">4. Key Extraction from Memory</a></h2>
<p><strong>Threat</strong>: Malware or physical access allows an attacker to dump device RAM and extract private keys.
<strong>Mitigation</strong>:</p>
<ul>
<li><strong>Hardware</strong>: Integration with TPM 2.0 ensures keys are non-exportable and operations happen inside the secure element.</li>
<li><strong>Software</strong>: The <code>software</code> provider uses the <code>zeroize</code> crate to wipe keys from memory immediately after use or on drop.</li>
</ul>
<h2 id="5-side-channel-attacks-sca"><a class="header" href="#5-side-channel-attacks-sca">5. Side-Channel Attacks (SCA)</a></h2>
<p><strong>Threat</strong>: Analyzing power consumption or timing to deduce private keys.
<strong>Mitigation</strong>:</p>
<ul>
<li>Underlying libraries (<code>pqcrypto-*</code>) utilize constant-time implementations where available.</li>
<li>Hardware offloading (TPM) provides physical resistance to SCA.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fips-140-3-compliance"><a class="header" href="#fips-140-3-compliance">FIPS 140-3 Compliance</a></h1>
<p>PQC-IIoT incorporates mandatory features required for FIPS 140-3 certification, easing the path for official validation of products built using this library.</p>
<h2 id="approved-mode-of-operation"><a class="header" href="#approved-mode-of-operation">Approved Mode of Operation</a></h2>
<p>The library enforces an <strong>Approved Mode of Operation</strong> which restricts the algorithms and configurations to those vetted by NIST (or in the process of standardization like Kyber/Falcon).</p>
<h3 id="enabling-approved-mode"><a class="header" href="#enabling-approved-mode">Enabling Approved Mode</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This flag enforces FIPS checks
std::env::set_var("PQC_IIOT_FIPS_MODE", "1");
<span class="boring">}</span></code></pre></pre>
<h2 id="power-on-self-tests-post"><a class="header" href="#power-on-self-tests-post">Power-On Self-Tests (POST)</a></h2>
<p>Upon initialization, the library automatically runs Known Answer Tests (KAT) for:</p>
<ul>
<li><strong>AES-256-GCM</strong> (Encryption/Decryption)</li>
<li><strong>SHA-256</strong> (Hashing)</li>
<li><strong>Kyber-768</strong> (KEM Encapsulate/Decapsulate)</li>
<li><strong>Falcon-512</strong> (Sign/Verify)</li>
</ul>
<p>If any test fails, the library panics and refuses to start, ensuring no cryptographic operations are performed with faulty logic.</p>
<h2 id="integrity-checks"><a class="header" href="#integrity-checks">Integrity Checks</a></h2>
<p>A software integrity check (using SHA-256) verifies that critical configuration and module components have not been tampered with on disk before loading.</p>
<h2 id="conditional-self-tests"><a class="header" href="#conditional-self-tests">Conditional Self-Tests</a></h2>
<ul>
<li><strong>Pairwisie Consistency Test (PCT)</strong>: Every time a new key pair is generated, a PCT is run (Sign/Verify for signature keys, Encaps/Decaps for KEM keys) to verify correctness before the keys are used.</li>
</ul>
<h2 id="zeroization"><a class="header" href="#zeroization">Zeroization</a></h2>
<p>Sensitive data (Private Keys, Shared Secrets) is actively overwritten with zeros using the <code>zeroize</code> crate when the memory is deallocated (<code>Drop</code> trait) or explicitly cleared.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="usage-guide"><a class="header" href="#usage-guide">Usage Guide</a></h1>
<p>This guide provides step-by-step instructions on integrating <strong>PQC-IIoT</strong> into your industrial applications.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li><strong>Rust Toolchain</strong>: Stable channel (v1.70+ recommended).</li>
<li><strong>Network Access</strong>: Devices must be able to reach the MQTT broker or CoAP server.</li>
<li><strong>Hardware</strong>: Any target supported by Rust (x86_64, ARMv7, AArch64, RISC-V).</li>
</ul>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Add <code>pqc-iiot</code> to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
pqc-iiot = { git = "https://github.com/doomhammerhell/pqc-iiot", branch = "main" }
</code></pre>
<h2 id="basic-initialization"><a class="header" href="#basic-initialization">Basic Initialization</a></h2>
<p>Initialize the <code>SecurityProvider</code> (Defaults to Software):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use pqc_iiot::security::provider::SoftwareSecurityProvider;

let provider = SoftwareSecurityProvider::new();
<span class="boring">}</span></code></pre></pre>
<p>See specific guides for <a href="usage/mqtt.html">MQTT</a> and <a href="usage/coap.html">CoAP</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-mqtt-integration"><a class="header" href="#secure-mqtt-integration">Secure MQTT Integration</a></h1>
<p>The <code>SecureMqttClient</code> wraps standard MQTT functionality with post-quantum security layers.</p>
<h2 id="example-secure-publisher"><a class="header" href="#example-secure-publisher">Example: Secure Publisher</a></h2>
<pre><pre class="playground"><code class="language-rust">use pqc_iiot::SecureMqttClient;
use std::time::Duration;

#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 1. Initialize Client
    // This automatically generates keys or loads them from 'pqc-data/identity_client_id.json'
    let mut client = SecureMqttClient::new("broker.hivemq.com", 1883, "sensor_01")?;

    // 2. Perform Key Exchange
    // Publishes public keys to 'pqc/keys/sensor_01'
    client.bootstrap()?;

    // 3. Publish Encrypted Data
    let payload = b"{\"temp\": 25.5, \"unit\": \"C\"}";
    
    // Encrypts using Kyber+AES and Signs using Falcon
    client.publish_encrypted("sensors/data", payload)?;
    
    // 4. Processing Loop
    loop {
        // Polls implementation handles decryption and handshake messages
        client.poll(|topic, payload| {
            println!("Received on {}: {:?}", topic, String::from_utf8_lossy(payload));
        })?;
        std::thread::sleep(Duration::from_secs(1));
    }
}</code></pre></pre>
<h2 id="critical-configuration"><a class="header" href="#critical-configuration">Critical Configuration</a></h2>
<p>To enable <strong>Strict Authentication</strong>, you must pre-load trusted identities:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Load trusted keys from a secure source
let trusted_keys = load_trusted_keys(); 
client.add_trusted_peer("controller_01", trusted_keys.falcon_pk);
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-coap-integration"><a class="header" href="#secure-coap-integration">Secure CoAP Integration</a></h1>
<p>The <code>SecureCoapClient</code> provides secure Request/Response patterns over UDP using Hybrid Encryption.</p>
<h2 id="example-secure-get-request"><a class="header" href="#example-secure-get-request">Example: Secure GET Request</a></h2>
<pre><pre class="playground"><code class="language-rust">use pqc_iiot::SecureCoapClient;
use std::net::SocketAddr;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // 1. Initialize Client
    let client = SecureCoapClient::new()?;
    
    let server_addr: SocketAddr = "127.0.0.1:5683".parse()?;
    
    // 2. Send Encrypted GET
    // Automatically performs handshake if session keys are missing
    let response = client.get(server_addr, "sensors/temp")?;
    
    // 3. Verify Response
    // Decrypts payload and verifies Falcon signature
    let payload = client.verify_response(&amp;response)?;
    
    println!("Response: {:?}", String::from_utf8_lossy(&amp;payload));
    
    Ok(())
}</code></pre></pre>
<h2 id="protocol-details"><a class="header" href="#protocol-details">Protocol Details</a></h2>
<p>Unlike DTLS, which secures the transport layer, PQC-IIoT secures the <strong>Application Payload</strong>.</p>
<ul>
<li><strong>Request</strong>: <code>[ Kyber Capsule | AES-Encrypted(Payload + Seq) | Falcon Sig ]</code></li>
<li><strong>Response</strong>: <code>[ AES-Encrypted(Payload + Seq) | Falcon Sig ]</code></li>
</ul>
<p>This means metadata (Options, URI) is visible, but the data is quantum-resistant.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hardware-integration"><a class="header" href="#hardware-integration">Hardware Integration</a></h1>
<p>PQC-IIoT is designed to run securely on general-purpose hardware but supports enhanced security through dedicated hardware integration.</p>
<h2 id="supported-hardware"><a class="header" href="#supported-hardware">Supported Hardware</a></h2>
<ul>
<li><strong>TPM 2.0</strong>: Using the <code>tss-esapi</code> crate standard.</li>
<li><strong>Secure Elements (SE)</strong>: Interface for I2C/SPI connected secure elements (e.g., ATECC608, SE050).</li>
<li><strong>HSM</strong>: PKCS#11 support (Planned).</li>
</ul>
<h2 id="integration-pattern"><a class="header" href="#integration-pattern">Integration Pattern</a></h2>
<p>The library uses the <code>SecurityProvider</code> trait to abstract hardware details.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Your custom provider implementation
struct TpmProvider { ... }

impl SecurityProvider for TpmProvider {
    fn sign(&amp;self, msg: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // Send command to TPM to sign
        // Private key never leaves TPM
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tpm-20-integration"><a class="header" href="#tpm-20-integration">TPM 2.0 Integration</a></h1>
<p>Trusted Platform Modules (TPM) provide a hardware root of trust. PQC-IIoT can leverage TPMs for:</p>
<ul>
<li><strong>Key Generation</strong>: Keys are generated inside the TPM and never exposed.</li>
<li><strong>Signing</strong>: Falcon signing operations are performed by the TPM (if supported) or keys are unsealed only into secure memory.</li>
<li><strong>Platform Integrity</strong>: Validating the boot state (PCRs) before releasing keys.</li>
</ul>
<h2 id="implementation-status"><a class="header" href="#implementation-status">Implementation Status</a></h2>
<p>Currently, standard TPMs do not natively support Kyber or Falcon.
<strong>Our Approach</strong>:</p>
<ol>
<li><strong>Hybrid Mode</strong>: Use TPM to seal (encrypt) the PQC keys at rest.</li>
<li><strong>Unsealing</strong>: Keys are decrypted only into RAM protected by <code>Zeroize</code> when the application starts and PCRs match.</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Logical flow
let encrypted_key_blob = load_from_disk();
let key = tpm.unseal(encrypted_key_blob)?; // Fails if boot chain compromised
let provider = SoftwareSecurityProvider::new(key);
// ... use provider ...
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="secure-elements-se"><a class="header" href="#secure-elements-se">Secure Elements (SE)</a></h1>
<p>For embedded devices without a TPM, Secure Elements (like NXP SE050 or Microchip ATECC608) offer similar protection.</p>
<h2 id="integration"><a class="header" href="#integration">Integration</a></h2>
<p>PQC-IIoT can offload the <strong>AES-GCM</strong> encryption to a Secure Element to protect the session data, while handling the PQC Key Exchange in software (as SEs typically lack PQC support currently).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl SecurityProvider for MySecureElement {
    fn decrypt(&amp;self, ciphertext: &amp;[u8]) -&gt; Result&lt;Vec&lt;u8&gt;&gt; {
        // Offload AES decryption to SE
        se_driver.aes_gcm_decrypt(...)
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api-reference"><a class="header" href="#api-reference">API Reference</a></h1>
<p>This section provides a high-level overview of the primary public APIs. For detailed documentation, run <code>cargo doc --open</code>.</p>
<h2 id="core-modules"><a class="header" href="#core-modules">Core Modules</a></h2>
<ul>
<li><strong><code>pqc_iiot::SecureMqttClient</code></strong>: Main client for MQTT communication.</li>
<li><strong><code>pqc_iiot::SecureCoapClient</code></strong>: Main client for CoAP communication.</li>
<li><strong><code>pqc_iiot::security::keystore</code></strong>: Manages trusted identities and keys.</li>
<li><strong><code>pqc_iiot::security::provider</code></strong>: Interfaces for hardware integration.</li>
</ul>
<h2 id="key-traits"><a class="header" href="#key-traits">Key Traits</a></h2>
<h3 id="securityprovider"><a class="header" href="#securityprovider"><code>SecurityProvider</code></a></h3>
<p>The contract for all cryptographic operations.</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>kem_public_key</code></td><td>Returns the Kyber public key</td></tr>
<tr><td><code>sig_public_key</code></td><td>Returns the Falcon public key</td></tr>
<tr><td><code>decrypt</code></td><td>Hybrid decryption (Decaps + AES-GCM)</td></tr>
<tr><td><code>sign</code></td><td>Generates a detached Falcon signature</td></tr>
</tbody></table>
</div>
<h3 id="securitylevel"><a class="header" href="#securitylevel"><code>Securitylevel</code></a></h3>
<p>Configuration for Kyber/Falcon parameter sets (Level 1, 3, 5).</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
